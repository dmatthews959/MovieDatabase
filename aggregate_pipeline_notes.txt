

Schema Overview
Your documents look like this:
{
  "_id": ObjectId,
  "title": "Inception",
  "runtime": 148,
  "director": "Christopher Nolan",
  "actors": ["Leonardo DiCaprio", "Joseph Gordon-Levitt"],
  "genre": ["Sci-Fi", "Thriller"],
  "year": 2010,
  "reviews": [
    { "rating": 5, "comment": "Amazing!" },
    { "rating": 4, "comment": "Great visuals." }
  ]
}



1. Average Rating per Movie
[
  { $addFields: {
      avgRating: { $avg: "$reviews.rating" }
    }
  },
  { $project: {
      title: 1,
      avgRating: 1
    }
  }
]



2. Top 5 Movies by Average Rating
[
  { $addFields: {
      avgRating: { $avg: "$reviews.rating" }
    }
  },
  { $sort: { avgRating: -1 } },
  { $limit: 5 },
  { $project: {
      title: 1,
      avgRating: 1
    }
  }
]



3. Movies Released per Year
[
  { $group: {
      _id: "$year",
      count: { $sum: 1 }
    }
  },
  { $sort: { _id: 1 } }
]



4. Most Prolific Directors
[
  { $group: {
      _id: "$director",
      movieCount: { $sum: 1 }
    }
  },
  { $sort: { movieCount: -1 } },
  { $limit: 5 }
]



5. Movies Featuring a Specific Actor
[
  { $match: {
      actors: "Leonardo DiCaprio"
    }
  },
  { $project: {
      title: 1,
      year: 1
    }
  }
]



6. Genre Popularity
[
  { $unwind: "$genre" },
  { $group: {
      _id: "$genre",
      count: { $sum: 1 }
    }
  },
  { $sort: { count: -1 } }
]



7. Average Runtime by Genre
[
  { $unwind: "$genre" },
  { $group: {
      _id: "$genre",
      avgRuntime: { $avg: "$runtime" }
    }
  },
  { $sort: { avgRuntime: -1 } }
]

Thanks for the clarification, Declan! Here's how you can implement each MongoDB aggregation pipeline as a separate Flask endpoint using PyMongo.

Setup
Install dependencies:
pip install flask pymongo


Initialize your Flask app and MongoDB connection:
# app.py
from flask import Flask, jsonify, request
from pymongo import MongoClient

app = Flask(__name__)
client = MongoClient("mongodb://localhost:27017/")
db = client["movies_db"]
movies = db["movies"]



Flask Endpoints
1. /movies/ratings â€“ Average rating per movie
@app.route('/movies/ratings', methods=['GET'])
def average_ratings():
    pipeline = [
        { "$addFields": { "avgRating": { "$avg": "$reviews.rating" } } },
        { "$project": { "title": 1, "avgRating": 1 } }
    ]
    result = list(movies.aggregate(pipeline))
    return jsonify(result)



2. /movies/top-rated â€“ Top 5 movies by average rating
@app.route('/movies/top-rated', methods=['GET'])
def top_rated_movies():
    pipeline = [
        { "$addFields": { "avgRating": { "$avg": "$reviews.rating" } } },
        { "$sort": { "avgRating": -1 } },
        { "$limit": 5 },
        { "$project": { "title": 1, "avgRating": 1 } }
    ]
    result = list(movies.aggregate(pipeline))
    return jsonify(result)



3. /movies/yearly-count â€“ Movies released per year
@app.route('/movies/yearly-count', methods=['GET'])
def movies_per_year():
    pipeline = [
        { "$group": { "_id": "$year", "count": { "$sum": 1 } } },
        { "$sort": { "_id": 1 } }
    ]
    result = list(movies.aggregate(pipeline))
    return jsonify(result)



4. /movies/directors/top â€“ Most prolific directors
@app.route('/movies/directors/top', methods=['GET'])
def top_directors():
    pipeline = [
        { "$group": { "_id": "$director", "movieCount": { "$sum": 1 } } },
        { "$sort": { "movieCount": -1 } },
        { "$limit": 5 }
    ]
    result = list(movies.aggregate(pipeline))
    return jsonify(result)



5. /movies/actor/<name> â€“ Movies featuring a specific actor
@app.route('/movies/actor/<name>', methods=['GET'])
def movies_by_actor(name):
    result = list(movies.find({ "actors": name }, { "title": 1, "year": 1, "_id": 0 }))
    return jsonify(result)

î·™î·š

6. /movies/genres/popularity â€“ Genre popularity
@app.route('/movies/genres/popularity', methods=['GET'])
def genre_popularity():
    pipeline = [
        { "$unwind": "$genre" },
        { "$group": { "_id": "$genre", "count": { "$sum": 1 } } },
        { "$sort": { "count": -1 } }
    ]
    result = list(movies.aggregate(pipeline))
    return jsonify(result)



7. /movies/genres/runtime â€“ Average runtime by genre
@app.route('/movies/genres/runtime', methods=['GET'])
def avg_runtime_by_genre():
    pipeline = [
        { "$unwind": "$genre" },
        { "$group": { "_id": "$genre", "avgRuntime": { "$avg": "$runtime" } } },
        { "$sort": { "avgRuntime": -1 } }
    ]
    result = list(movies.aggregate(pipeline))
    return jsonify(result)


Run the App
if __name__ == '__main__':
    app.run(debug=True)


What is $addFields

Great question! In MongoDB's aggregation framework, $addFields is a stage that lets you add new fields to documents or redefine existing ones as they pass through the pipeline â€” without removing any of the original fields.

What It Does
- Adds computed fields to each document.
- Keeps all existing fields intact.
- Can be used to reshape documents mid-pipeline.

Syntax
{ $addFields: { newField: <expression>, ... } }



Example
Letâ€™s say you have this document:
{
  "title": "Inception",
  "reviews": [
    { "rating": 5 },
    { "rating": 4 }
  ]
}


And you want to calculate the average rating:
[
  {
    $addFields: {
      avgRating: { $avg: "$reviews.rating" }
    }
  }
]


This will produce:
{
  "title": "Inception",
  "reviews": [...],
  "avgRating": 4.5
}



Difference from $project
- $addFields: Adds or modifies fields, keeps everything else.
- $project: Controls which fields to include or exclude, and can also reshape.
You can even use them together â€” for example, use $addFields to compute something, then $project to return only what you want.


Ah, I see what you're asking now â€” you're wondering where the result of $addFields goes in your MongoDB database. Here's the key insight:

ðŸ§  $addFields Is Temporary in Aggregation
- The fields added by $addFields do not get saved to your database.
- They exist only within the aggregation pipeline â€” like a temporary computed column in SQL.
- If you want to persist the new field (e.g. avgRating) into your documents, you need to use an update operation.

ðŸ’¾ How to Save It Permanently
If you want to store avgRating in each movie document, you'd do something like this in Python (with PyMongo):
from pymongo import MongoClient

client = MongoClient("mongodb://localhost:27017/")
db = client["movies_db"]
movies = db["movies"]

# Compute and update avgRating for each movie
for movie in movies.find():
    ratings = [r["rating"] for r in movie.get("reviews", [])]
    avg = sum(ratings) / len(ratings) if ratings else None
    movies.update_one(
        { "_id": movie["_id"] },
        { "$set": { "avgRating": avg } }
    )


This will add a permanent avgRating field to each document in your collection.

ðŸ§ª When to Use $addFields vs $set
|  |  |  | 
|  | $addFields |  | 
|  | $setupdate_one |  | 



Would you like help writing a script to periodically update these fields, or maybe trigger it after new reviews are added?


